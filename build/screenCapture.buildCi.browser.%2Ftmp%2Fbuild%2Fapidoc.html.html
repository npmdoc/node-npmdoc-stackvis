<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/davepacheco/node-stackvis">stackvis (v0.4.0)</a>
</h1>
<h4>stack visualization tools</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.stackvis">module stackvis</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stackvis.pipeStacks">
            function <span class="apidocSignatureSpan">stackvis.</span>pipeStacks
            <span class="apidocSignatureSpan">(log, instream, readercons, writer, outstream, args, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stackvis.readerLookup">
            function <span class="apidocSignatureSpan">stackvis.</span>readerLookup
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stackvis.writerLookup">
            function <span class="apidocSignatureSpan">stackvis.</span>writerLookup
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>stackvis</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stackvis.</span>color</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stackvis.</span>input_collapsed</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stackvis.</span>input_dtrace</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stackvis.</span>input_perf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stackvis.</span>input_stap</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stackvis.</span>output_collapsed</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stackvis.</span>output_flamegraph_d3</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stackvis.</span>output_flamegraph_svg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stackvis.</span>xml</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stackvis.color">module stackvis.color</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stackvis.color.convertHsvToRgb">
            function <span class="apidocSignatureSpan">stackvis.color.</span>convertHsvToRgb
            <span class="apidocSignatureSpan">(h, s, v)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stackvis.input_collapsed">module stackvis.input_collapsed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stackvis.input_collapsed.reader">
            function <span class="apidocSignatureSpan">stackvis.input_collapsed.</span>reader
            <span class="apidocSignatureSpan">(input, log)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stackvis.input_dtrace">module stackvis.input_dtrace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stackvis.input_dtrace.reader">
            function <span class="apidocSignatureSpan">stackvis.input_dtrace.</span>reader
            <span class="apidocSignatureSpan">(input, log)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stackvis.input_perf">module stackvis.input_perf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stackvis.input_perf.reader">
            function <span class="apidocSignatureSpan">stackvis.input_perf.</span>reader
            <span class="apidocSignatureSpan">(input, log)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stackvis.input_stap">module stackvis.input_stap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stackvis.input_stap.reader">
            function <span class="apidocSignatureSpan">stackvis.input_stap.</span>reader
            <span class="apidocSignatureSpan">(input, log)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stackvis.output_collapsed">module stackvis.output_collapsed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stackvis.output_collapsed.emit">
            function <span class="apidocSignatureSpan">stackvis.output_collapsed.</span>emit
            <span class="apidocSignatureSpan">(args, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stackvis.output_flamegraph_d3">module stackvis.output_flamegraph_d3</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stackvis.output_flamegraph_d3.emit">
            function <span class="apidocSignatureSpan">stackvis.output_flamegraph_d3.</span>emit
            <span class="apidocSignatureSpan">(args, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stackvis.output_flamegraph_svg">module stackvis.output_flamegraph_svg</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stackvis.output_flamegraph_svg.emit">
            function <span class="apidocSignatureSpan">stackvis.output_flamegraph_svg.</span>emit
            <span class="apidocSignatureSpan">(args, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stackvis.stackvis">module stackvis.stackvis</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stackvis.stackvis.pipeStacks">
            function <span class="apidocSignatureSpan">stackvis.stackvis.</span>pipeStacks
            <span class="apidocSignatureSpan">(log, instream, readercons, writer, outstream, args, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stackvis.stackvis.readerLookup">
            function <span class="apidocSignatureSpan">stackvis.stackvis.</span>readerLookup
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stackvis.stackvis.writerLookup">
            function <span class="apidocSignatureSpan">stackvis.stackvis.</span>writerLookup
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stackvis.xml">module stackvis.xml</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stackvis.xml.XmlEmitter">
            function <span class="apidocSignatureSpan">stackvis.xml.</span>XmlEmitter
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stackvis" id="apidoc.module.stackvis">module stackvis</a></h1>


    <h2>
        <a href="#apidoc.element.stackvis.pipeStacks" id="apidoc.element.stackvis.pipeStacks">
        function <span class="apidocSignatureSpan">stackvis.</span>pipeStacks
        <span class="apidocSignatureSpan">(log, instream, readercons, writer, outstream, args, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pipeStacks(log, instream, readercons, writer, outstream, args, callback)
{
	if (typeof (args) === 'function') {
		callback = args;
		args = {};
	}
	args = args || {};

	var reader = new readercons(instream, log);

	collapseStacks(reader, function (err, stacks) {
		if (err) {
			log.error(err);
			return;
		}

		var _args = mod_jsprim.deepCopy(args);
		_args.stacks = stacks;
		_args.output = outstream;
		_args.log = log;
		writer.emit(_args, function (err2) {
			<span class="apidocCodeCommentSpan">/*
			 * It's stupid that we need to check whether we're
			 * writing to stdout, but this is the same thing Node's
			 * stream.pipe() method does, because for some reason
			 * you can't "end" the stdout stream.
			 */
</span>			if (!err2 &amp;&amp; !outstream._isStdio)
				outstream.end();

			callback(err2);
		});
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```
The main operation is translating from one representation to another (e.g.,
DTrace output to a flame graph) using pipeStacks() (which requires a Bunyan
logger):
```javascript
var mod_bunyan = require('bunyan');
var log = new mod_bunyan({ 'name': 'mytool', 'stream': process.stderr });
mod_stackvis.<span class="apidocCodeKeywordSpan">pipeStacks</span>(log, process.stdin, dtrace_reader, collapsed_writer,
    process.stdout, function () { console.error('translation finished'); });
```
This example instantiates a new dtrace_reader to read DTrace output from
process.stdin and then emits the result in collapsed form to process.stdout
through the collapsed_writer.

## Adding new readers and writers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stackvis.readerLookup" id="apidoc.element.stackvis.readerLookup">
        function <span class="apidocSignatureSpan">stackvis.</span>readerLookup
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readerLookup(name)
{
	return (moduleLookup('input', name).reader);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- output-flamegraph-svg.js: writes stacks as a flame graph SVG
- output-flamegraph-d3.js: writes stacks as a flame graph HTML file using D3

Client code shouldn't load these directly.  Instead, require 'stackvis' and use
lookupReader and lookupWriter:
```javascript
var mod_stackvis = require('stackvis');
var dtrace_reader = mod_stackvis.<span class="apidocCodeKeywordSpan">readerLookup</span>('dtrace');
var collapsed_writer = mod_stackvis.writerLookup('collapsed');
```
The main operation is translating from one representation to another (e.g.,
DTrace output to a flame graph) using pipeStacks() (which requires a Bunyan
logger):
```javascript
var mod_bunyan = require('bunyan');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stackvis.writerLookup" id="apidoc.element.stackvis.writerLookup">
        function <span class="apidocSignatureSpan">stackvis.</span>writerLookup
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writerLookup(name)
{
	return (moduleLookup('output', name));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- output-flamegraph-d3.js: writes stacks as a flame graph HTML file using D3

Client code shouldn't load these directly.  Instead, require 'stackvis' and use
lookupReader and lookupWriter:
```javascript
var mod_stackvis = require('stackvis');
var dtrace_reader = mod_stackvis.readerLookup('dtrace');
var collapsed_writer = mod_stackvis.<span class="apidocCodeKeywordSpan">writerLookup</span>('collapsed');
```
The main operation is translating from one representation to another (e.g.,
DTrace output to a flame graph) using pipeStacks() (which requires a Bunyan
logger):
```javascript
var mod_bunyan = require('bunyan');
var log = new mod_bunyan({ 'name': 'mytool', 'stream': process.stderr });
...</pre></li>
    </ul>






















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stackvis.color" id="apidoc.module.stackvis.color">module stackvis.color</a></h1>


    <h2>
        <a href="#apidoc.element.stackvis.color.convertHsvToRgb" id="apidoc.element.stackvis.color.convertHsvToRgb">
        function <span class="apidocSignatureSpan">stackvis.color.</span>convertHsvToRgb
        <span class="apidocSignatureSpan">(h, s, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertHsvToRgb(h, s, v)
{
	var r, g, b;
	var i;
	var f, p, q, t;

	mod_assert.ok(h &gt;= 0 &amp;&amp; h &lt;= 360, 'hue (' + h + ') out of range');
	mod_assert.ok(s &gt;= 0 &amp;&amp; s &lt;= 1, 'saturation (' + s + ') out of range');
	mod_assert.ok(v &gt;= 0 &amp;&amp; v &lt;= 1, 'value (' + v + ') out of range');

	if (s === 0) {
		<span class="apidocCodeCommentSpan">/*
		 * A saturation of 0.0 is achromatic (grey).
		 */
</span>		r = g = b = v;

		return ([ Math.round(r * 255), Math.round(g * 255),
		    Math.round(b * 255) ]);
	}

	h /= 60; // sector 0 to 5

	i = Math.floor(h);
	f = h - i; // fractional part of h
	p = v * (1 - s);
	q = v * (1 - s * f);
	t = v * (1 - s * (1 - f));

	switch (i) {
		case 0:
			r = v;
			g = t;
			b = p;
			break;

		case 1:
			r = q;
			g = v;
			b = p;
			break;

		case 2:
			r = p;
			g = v;
			b = t;
			break;

		case 3:
			r = p;
			g = q;
			b = v;
			break;

		case 4:
			r = t;
			g = p;
			b = v;
			break;

		default: // case 5:
			r = v;
			g = p;
			b = q;
			break;
	}

	return ([ Math.round(r * 255),
	    Math.round(g * 255), Math.round(b * 255) ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	var hratio = depth / this.fge_maxdepth;
	var sratio = samples / this.fge_depthsamples[depth];

	var rh = h + hratio * hplus;
	var rs = (s + sratio * splus) / 100;
	var rv = (v + hratio * vplus) / 100;
	var rgb = mod_color.<span class="apidocCodeKeywordSpan">convertHsvToRgb</span>(rh, rs, rv);

	return ('rgb(' + rgb.join(',') + ')');
};

FlameGraphEmitter.prototype.draw = function (callback)
{
	var xml = new mod_xml.XmlEmitter(this.fge_output);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stackvis.input_collapsed" id="apidoc.module.stackvis.input_collapsed">module stackvis.input_collapsed</a></h1>


    <h2>
        <a href="#apidoc.element.stackvis.input_collapsed.reader" id="apidoc.element.stackvis.input_collapsed.reader">
        function <span class="apidocSignatureSpan">stackvis.input_collapsed.</span>reader
        <span class="apidocSignatureSpan">(input, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CollapsedStreamReader(input, log)
{
	var reader = this;

	this.csr_log = log;
	this.csr_linenum = 0;
	this.csr_carrier = mod_carrier.carry(input);
	this.csr_carrier.on('line', function (line) {
		reader.csr_linenum++;
		var match = /^(.*)\s+(\d+)$/.exec(line);
		if (!match) {
			log.warn('line ' + reader.csr_linenum + ': garbled');
			return;
		}

		reader.emit('stack', match[1].split(','),
		    parseInt(match[2], 10));
	});
	this.csr_carrier.on('end', function () { reader.emit('end'); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stackvis.input_dtrace" id="apidoc.module.stackvis.input_dtrace">module stackvis.input_dtrace</a></h1>


    <h2>
        <a href="#apidoc.element.stackvis.input_dtrace.reader" id="apidoc.element.stackvis.input_dtrace.reader">
        function <span class="apidocSignatureSpan">stackvis.input_dtrace.</span>reader
        <span class="apidocSignatureSpan">(input, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DTraceStreamReader(input, log)
{
	this.dsr_log = log;
	this.dsr_linenum = 0;
	this.dsr_stack = [];
	this.dsr_carrier = mod_carrier.carry(input);
	this.dsr_carrier.on('line', this.onLine.bind(this));
	this.dsr_carrier.on('end', this.onEnd.bind(this));

	mod_events.EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stackvis.input_perf" id="apidoc.module.stackvis.input_perf">module stackvis.input_perf</a></h1>


    <h2>
        <a href="#apidoc.element.stackvis.input_perf.reader" id="apidoc.element.stackvis.input_perf.reader">
        function <span class="apidocSignatureSpan">stackvis.input_perf.</span>reader
        <span class="apidocSignatureSpan">(input, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PerfStreamReader(input, log)
{
	this.dsr_log = log;
	this.dsr_linenum = 0;
	this.dsr_prefix = '';
	this.dsr_stack = [];
	this.dsr_carrier = mod_carrier.carry(input);
	this.dsr_carrier.on('line', this.onLine.bind(this));
	this.dsr_carrier.on('end', this.onEnd.bind(this));

	mod_events.EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stackvis.input_stap" id="apidoc.module.stackvis.input_stap">module stackvis.input_stap</a></h1>


    <h2>
        <a href="#apidoc.element.stackvis.input_stap.reader" id="apidoc.element.stackvis.input_stap.reader">
        function <span class="apidocSignatureSpan">stackvis.input_stap.</span>reader
        <span class="apidocSignatureSpan">(input, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PerfStreamReader(input, log)
{
	this.dsr_log = log;
	this.dsr_linenum = 0;
	this.dsr_addingframes = false;
	this.dsr_prefixes = [];
	this.dsr_stack = [];
	this.dsr_carrier = mod_carrier.carry(input);
	this.dsr_carrier.on('line', this.onLine.bind(this));
	this.dsr_carrier.on('end', this.onEnd.bind(this));

	mod_events.EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stackvis.output_collapsed" id="apidoc.module.stackvis.output_collapsed">module stackvis.output_collapsed</a></h1>


    <h2>
        <a href="#apidoc.element.stackvis.output_collapsed.emit" id="apidoc.element.stackvis.output_collapsed.emit">
        function <span class="apidocSignatureSpan">stackvis.output_collapsed.</span>emit
        <span class="apidocSignatureSpan">(args, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitCollapsed(args, callback)
{
	mod_assert.ok(args.stacks &amp;&amp; args.stacks.constructor &amp;&amp;
	    args.stacks.constructor.name == 'StackSet',
	    'required "stacks" argument must be a StackSet');
	mod_assert.ok(args.output &amp;&amp; args.output.write &amp;&amp;
	    typeof (args.output.write) == 'function',
	    'required "output" argument must be a function');

	args.stacks.eachStackByCount(function (frames, count) {
		args.output.write(frames.join(',') + ' ' + count + '\n');
	});
	callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		reader.csr_linenum++;
		var match = /^(.*)\s+(\d+)$/.exec(line);
		if (!match) {
			log.warn('line ' + reader.csr_linenum + ': garbled');
			return;
		}

		reader.<span class="apidocCodeKeywordSpan">emit</span>('stack', match[1].split(','),
		    parseInt(match[2], 10));
	});
	this.csr_carrier.on('end', function () { reader.emit('end'); });
}

mod_util.inherits(CollapsedStreamReader, mod_events.EventEmitter);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stackvis.output_flamegraph_d3" id="apidoc.module.stackvis.output_flamegraph_d3">module stackvis.output_flamegraph_d3</a></h1>


    <h2>
        <a href="#apidoc.element.stackvis.output_flamegraph_d3.emit" id="apidoc.element.stackvis.output_flamegraph_d3.emit">
        function <span class="apidocSignatureSpan">stackvis.output_flamegraph_d3.</span>emit
        <span class="apidocSignatureSpan">(args, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitIcicleData(args, callback)
{
	mod_assert.ok(args.stacks &amp;&amp; args.stacks.constructor &amp;&amp;
	    args.stacks.constructor.name == 'StackSet',
	    'required "stacks" argument must be a StackSet');
	mod_assert.ok(args.output &amp;&amp; args.output.write &amp;&amp;
	    typeof (args.output.write) == 'function',
	    'required "output" argument must be a function');
	mod_assert.ok(args.log, 'required "log" argument must be a logger');

	var stacks = args.stacks;
	var output = args.output;
	var tree = {};
	var filecontents = {};

	stacks.eachStackByStack(function (frames, count) {
		var subtree = tree;
		var node, i;

		for (i = 0; i &lt; frames.length; i++) {
			if (!subtree.hasOwnProperty(frames[i]))
				subtree[frames[i]] = {
				    svUnique: 0,
				    svTotal: 0,
				    svChildren: {}
				};

			node = subtree[frames[i]];
			node.svTotal += count;
			subtree = node.svChildren;
		}

		node.svUnique += count;
	});

	tree = {
	    '': {
		svUnique: 0,
		svTotal: Object.keys(tree).reduce(
		    function (p, c) { return (p + tree[c].svTotal); }, 0),
		svChildren: tree
	    }
	};

	mod_vasync.forEachParallel({
	    'inputs': [ 'icicle.css', 'icicle.js', 'icicle.htm', 'd3.v2.js' ],
	    'func': function (filename, stepcb) {
		var path = mod_path.join(__dirname, '../share', filename);
		var key = filename.replace(/\./g, '_');
		mod_fs.readFile(path, function (err, contents) {
			if (err)
				err = new VError(err, 'failed to load "%s"',
				    filename);
			else
				filecontents[key] = contents.toString('utf8');
			stepcb(err);
		});
	    }
	}, function (err) {
		if (err) {
			callback(err);
			return;
		}

		var compiled, rendered;

		filecontents['title'] = 'Flame graph';
		filecontents['rawdata'] = JSON.stringify(tree, null, '\t');
		compiled = mod_hogan.compile(filecontents['icicle_htm']);
		rendered = compiled.render(filecontents);
		output.write(rendered);
		callback();
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		reader.csr_linenum++;
		var match = /^(.*)\s+(\d+)$/.exec(line);
		if (!match) {
			log.warn('line ' + reader.csr_linenum + ': garbled');
			return;
		}

		reader.<span class="apidocCodeKeywordSpan">emit</span>('stack', match[1].split(','),
		    parseInt(match[2], 10));
	});
	this.csr_carrier.on('end', function () { reader.emit('end'); });
}

mod_util.inherits(CollapsedStreamReader, mod_events.EventEmitter);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stackvis.output_flamegraph_svg" id="apidoc.module.stackvis.output_flamegraph_svg">module stackvis.output_flamegraph_svg</a></h1>


    <h2>
        <a href="#apidoc.element.stackvis.output_flamegraph_svg.emit" id="apidoc.element.stackvis.output_flamegraph_svg.emit">
        function <span class="apidocSignatureSpan">stackvis.output_flamegraph_svg.</span>emit
        <span class="apidocSignatureSpan">(args, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitFlameGraph(args, callback)
{
	var emitter = new FlameGraphEmitter(args);
	emitter.run(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		reader.csr_linenum++;
		var match = /^(.*)\s+(\d+)$/.exec(line);
		if (!match) {
			log.warn('line ' + reader.csr_linenum + ': garbled');
			return;
		}

		reader.<span class="apidocCodeKeywordSpan">emit</span>('stack', match[1].split(','),
		    parseInt(match[2], 10));
	});
	this.csr_carrier.on('end', function () { reader.emit('end'); });
}

mod_util.inherits(CollapsedStreamReader, mod_events.EventEmitter);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stackvis.stackvis" id="apidoc.module.stackvis.stackvis">module stackvis.stackvis</a></h1>


    <h2>
        <a href="#apidoc.element.stackvis.stackvis.pipeStacks" id="apidoc.element.stackvis.stackvis.pipeStacks">
        function <span class="apidocSignatureSpan">stackvis.stackvis.</span>pipeStacks
        <span class="apidocSignatureSpan">(log, instream, readercons, writer, outstream, args, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pipeStacks(log, instream, readercons, writer, outstream, args, callback)
{
	if (typeof (args) === 'function') {
		callback = args;
		args = {};
	}
	args = args || {};

	var reader = new readercons(instream, log);

	collapseStacks(reader, function (err, stacks) {
		if (err) {
			log.error(err);
			return;
		}

		var _args = mod_jsprim.deepCopy(args);
		_args.stacks = stacks;
		_args.output = outstream;
		_args.log = log;
		writer.emit(_args, function (err2) {
			<span class="apidocCodeCommentSpan">/*
			 * It's stupid that we need to check whether we're
			 * writing to stdout, but this is the same thing Node's
			 * stream.pipe() method does, because for some reason
			 * you can't "end" the stdout stream.
			 */
</span>			if (!err2 &amp;&amp; !outstream._isStdio)
				outstream.end();

			callback(err2);
		});
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```
The main operation is translating from one representation to another (e.g.,
DTrace output to a flame graph) using pipeStacks() (which requires a Bunyan
logger):
```javascript
var mod_bunyan = require('bunyan');
var log = new mod_bunyan({ 'name': 'mytool', 'stream': process.stderr });
mod_stackvis.<span class="apidocCodeKeywordSpan">pipeStacks</span>(log, process.stdin, dtrace_reader, collapsed_writer,
    process.stdout, function () { console.error('translation finished'); });
```
This example instantiates a new dtrace_reader to read DTrace output from
process.stdin and then emits the result in collapsed form to process.stdout
through the collapsed_writer.

## Adding new readers and writers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stackvis.stackvis.readerLookup" id="apidoc.element.stackvis.stackvis.readerLookup">
        function <span class="apidocSignatureSpan">stackvis.stackvis.</span>readerLookup
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readerLookup(name)
{
	return (moduleLookup('input', name).reader);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- output-flamegraph-svg.js: writes stacks as a flame graph SVG
- output-flamegraph-d3.js: writes stacks as a flame graph HTML file using D3

Client code shouldn't load these directly.  Instead, require 'stackvis' and use
lookupReader and lookupWriter:
```javascript
var mod_stackvis = require('stackvis');
var dtrace_reader = mod_stackvis.<span class="apidocCodeKeywordSpan">readerLookup</span>('dtrace');
var collapsed_writer = mod_stackvis.writerLookup('collapsed');
```
The main operation is translating from one representation to another (e.g.,
DTrace output to a flame graph) using pipeStacks() (which requires a Bunyan
logger):
```javascript
var mod_bunyan = require('bunyan');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stackvis.stackvis.writerLookup" id="apidoc.element.stackvis.stackvis.writerLookup">
        function <span class="apidocSignatureSpan">stackvis.stackvis.</span>writerLookup
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writerLookup(name)
{
	return (moduleLookup('output', name));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- output-flamegraph-d3.js: writes stacks as a flame graph HTML file using D3

Client code shouldn't load these directly.  Instead, require 'stackvis' and use
lookupReader and lookupWriter:
```javascript
var mod_stackvis = require('stackvis');
var dtrace_reader = mod_stackvis.readerLookup('dtrace');
var collapsed_writer = mod_stackvis.<span class="apidocCodeKeywordSpan">writerLookup</span>('collapsed');
```
The main operation is translating from one representation to another (e.g.,
DTrace output to a flame graph) using pipeStacks() (which requires a Bunyan
logger):
```javascript
var mod_bunyan = require('bunyan');
var log = new mod_bunyan({ 'name': 'mytool', 'stream': process.stderr });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stackvis.xml" id="apidoc.module.stackvis.xml">module stackvis.xml</a></h1>


    <h2>
        <a href="#apidoc.element.stackvis.xml.XmlEmitter" id="apidoc.element.stackvis.xml.XmlEmitter">
        function <span class="apidocSignatureSpan">stackvis.xml.</span>XmlEmitter
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function XmlEmitter(stream)
{
	this.xe_stream = stream;
	this.xe_stack = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var rgb = mod_color.convertHsvToRgb(rh, rs, rv);

	return ('rgb(' + rgb.join(',') + ')');
};

FlameGraphEmitter.prototype.draw = function (callback)
{
	var xml = new mod_xml.<span class="apidocCodeKeywordSpan">XmlEmitter</span>(this.fge_output);

	var fontface = this.fge_params['font_face'];
	var fontsize = this.fge_params['font_size'];

	var xpad = 10;
	var ypadtop = fontsize * 4 + fontsize * 2 + 10;
	var ypadbtm = fontsize * 2 + 10;
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>